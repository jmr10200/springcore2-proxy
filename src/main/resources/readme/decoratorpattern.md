#### 데코레이터 패턴
<br>

Decorator 기능에 일부 중복이 있다.<br>
꾸며주는 역할을 하는 Decorator 는 스스로 존재할 수 없다.<br>
항상 꾸며줄 대상이 있어야 한다. <br>
그래서 항상 내부에 꾸며주는 대상 Component 가 존재해야 한다.(호출필요)<br>
이 부분이 중복이다.<br>
이러한 중복을 제거하기 위해 Component 를 속성으로 가지고 있는 Decorator 라는 추상 클래스를 만드는 방법도 고민할 수 있다.<br>
이렇게 하면 추가로 클래스 다이어그램에서 어떤 것이 실제 컴포넌트인지, 데코레이터인지 명확하게 구분할 수 있다.<br>
여기까지 고민한 것이 GOF 에서 설명하는 **데코레이터 패턴** 의 기본 예제이다.<br>

<br>

###### 프록시 패턴 vs 데코레이터 패턴
* Decorator 라는 추상 클래스를 만들어야 데코레이터 패턴인가?
* 프록시 패턴과 데코레이터 패턴은 그 모양이 거의 비슷한것 같다?

##### 의도(intent)
프록시 패턴과 데코레이터 패턴은 그 모양이 거의 같고, 상황에 따라 정말 똑같을 때도 있다.<br>
그러면 이 둘을 어떻게 구분할 것인가?<br>
디자인 패턴에서 중요한 것은 해당 패턴의 겉 모습이 아니라 그 패턴을 만든 **의도** 가 더 중요하다.<br>
따라서 의도에 따라 패턴을 구분한다.<br>

* 프록시 패턴의 의도 :  다른 개체에 대한 **접근을 제어** 하기 위해 대리자를 제공
* 데코레이터 패턴의 의도 : **객체에 추가 책임(기능)을 동적으로 추가** 하고, 기능 확장을 위한 유연한 대안 제공

<br>

###### 정리
프록시를 사용하고 해당 프록시가 접근 제어가 목적이라면 프록시 패턴이고,<br>
새로운 기능을 추가하는 것이 목적이라면 데코레이터 패턴이다.<br>


